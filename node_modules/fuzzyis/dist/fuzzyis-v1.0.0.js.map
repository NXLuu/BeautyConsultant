{"version":3,"sources":["webpack:///fuzzyis-v1.0.0.js","webpack:///webpack/bootstrap 4e2f8f85568c34547f34","webpack:///./lib/index.js","webpack:///./lib/FIS.js","webpack:///./lib/CorrectedTerm.js","webpack:///./lib/UnionOfTerms.js","webpack:///./lib/helpers.js","webpack:///./lib/LinguisticVariable.js","webpack:///./lib/Term.js","webpack:///./lib/mfTypes.js","webpack:///./lib/Rule.js"],"names":["fuzzyis","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","FIS","LinguisticVariable","Term","Rule","_classCallCheck","instance","Constructor","TypeError","getLeftParts","inputValues","system","leftParts","inputsAmount","inputs","length","i","rules","push","j","conditions","term","findTerm","valueAt","getMassCenter","unionOfTerms","range","points","delta","S","currentStep","newS","half_S","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","CorrectedTerm","UnionOfTerms","helpers","name","arguments","undefined","outputs","this","value","LV","rule","rightParts","beliefDegree","connection","getMin","getMax","weight","conclusions","unionOfCorrectedTerms","union","k","results","result","Error","x","termValue","Math","min","arrayOfTerms","max","forEach","indexOfObjByAttr","array","attr","minOfTwoFunctions","f1","f2","point","getMinOrMaxOfTwoFunction","maxOfTwoFunctions","isMin","value1","value2","getMaxFromFunctions","arrayOfFunctions","func","objClear","obj","member","hasOwnProperty","terms","termName","index","splice","getDefaultParams","mf","args","parseFloat","toFixed","mfTypes","mfType","mfParams","slice","apply","mf_triangle","input","left","right","mf_trapezoidal","maxLeft","maxRight","mf_gaussian","concentration","exp","mf_sigmoid","steepness","transitionCoordinate","mf_singleton","number","triangle","trapeze","gauss","sigma","singleton","map","toLowerCase"],"mappings":"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","file":"fuzzyis-v1.0.0.js","sourcesContent":["var fuzzyis =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t    FIS: __webpack_require__(1),\n\t    LinguisticVariable: __webpack_require__(5),\n\t    Term: __webpack_require__(6),\n\t    Rule: __webpack_require__(8)\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CorrectedTerm = __webpack_require__(2);\n\tvar UnionOfTerms = __webpack_require__(3);\n\tvar helpers = __webpack_require__(4);\n\t\n\t/**\r\n\t * Describes Fuzzy Inference System\r\n\t * Put LinguisticVariables into inputs and outputs, describe system rules\r\n\t * And get precise outputs from precise input values.\r\n\t */\n\t\n\tvar FIS = function () {\n\t    /**\r\n\t     * Creates empty system without any rules and i/o linguistic variables\r\n\t     * @param {string} name\r\n\t     * @param {Array.<LinguisticVariable>} inputs\r\n\t     * @param {Array.<LinguisticVariable>} outputs\r\n\t     * @param {Array.<Rule>} rules\r\n\t     */\n\t    function FIS() {\n\t        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Unnamed system\";\n\t        var inputs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t        var outputs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t        var rules = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\t\n\t        _classCallCheck(this, FIS);\n\t\n\t        this.name = name;\n\t\n\t        // linguistic variables\n\t        this.inputs = inputs;\n\t        this.outputs = outputs;\n\t\n\t        this.rules = rules;\n\t    }\n\t\n\t    /**\r\n\t     * @param {LinguisticVariable} LV\r\n\t     */\n\t\n\t\n\t    _createClass(FIS, [{\n\t        key: 'addInput',\n\t        value: function addInput(LV) {\n\t            this.inputs.push(LV);\n\t        }\n\t\n\t        /**\r\n\t         * @param {LinguisticVariable} LV\r\n\t         */\n\t\n\t    }, {\n\t        key: 'addOutput',\n\t        value: function addOutput(LV) {\n\t            this.outputs.push(LV);\n\t        }\n\t\n\t        /**\r\n\t         * @param {Rule} rule\r\n\t         */\n\t\n\t    }, {\n\t        key: 'addRule',\n\t        value: function addRule(rule) {\n\t            this.rules.push(rule);\n\t        }\n\t\n\t        /**\r\n\t         * \r\n\t         * @param {Array.<number>} inputValues Precise values for input linguistic variables\r\n\t         * @returns {Array.<number>} Precise values for input linguistic variables\r\n\t         */\n\t\n\t    }, {\n\t        key: 'getPreciseOutput',\n\t        value: function getPreciseOutput(inputValues) {\n\t            var leftParts = getLeftParts(inputValues, this);\n\t\n\t            // for each Rule we should find belief degree\n\t\n\t            var rightParts = [];\n\t            var i = void 0;\n\t            for (i = 0; i < this.rules.length; i++) {\n\t                var rule = this.rules[i];\n\t                rule.beliefDegree = rule.connection === \"and\" ? helpers.getMin(leftParts[i]) : getMax(leftParts[i]);\n\t                rule.beliefDegree *= rule.weight;\n\t\n\t                // filling the right parts\n\t                rightParts.push([]);\n\t                for (var j = 0; j < rule.conclusions.length; j++) {\n\t                    var term = this.outputs[j].findTerm(rule.conclusions[j]);\n\t                    rightParts[i].push(new CorrectedTerm(term, rule.beliefDegree));\n\t                }\n\t            }\n\t\n\t            var unionOfCorrectedTerms = [];\n\t\n\t            //outputs\n\t            for (i = 0; i < this.outputs.length; i++) {\n\t                // rules\n\t                var union = [];\n\t                for (var k = 0; k < rightParts.length; k++) {\n\t                    union.push(rightParts[k][i]);\n\t                }\n\t                unionOfCorrectedTerms.push(new UnionOfTerms(union));\n\t            }\n\t\n\t            var results = [];\n\t\n\t            for (i = 0; i < this.outputs.length; i++) {\n\t                var result = getMassCenter(unionOfCorrectedTerms[i], this.outputs[i].range, 100);\n\t                results.push(result);\n\t            }\n\t\n\t            return results;\n\t        }\n\t    }]);\n\t\n\t    return FIS;\n\t}();\n\t\n\tmodule.exports = FIS;\n\t\n\t/**\r\n\t *\r\n\t * @param {Array.<LinguisticVariable>} inputValues\r\n\t * @param system {FIS}\r\n\t * @returns {Array}\r\n\t */\n\tfunction getLeftParts(inputValues, system) {\n\t    var leftParts = [];\n\t    var inputsAmount = system.inputs.length;\n\t    for (var i = 0; i < system.rules.length; i++) {\n\t        // for each Rule get values at the right parts\n\t        leftParts.push([]);\n\t        for (var j = 0; j < inputsAmount; j++) {\n\t            if (system.rules[i].conditions[j]) {\n\t                var term = system.inputs[j].findTerm(system.rules[i].conditions[j]);\n\t                leftParts[i].push(term.valueAt(inputValues[j]));\n\t            } else {\n\t                leftParts[i].push(null);\n\t            }\n\t        }\n\t    }\n\t\n\t    return leftParts;\n\t}\n\t\n\t/**\r\n\t * Searches for point in which Square under f equals to half on specific interval.\r\n\t * @param {UnionOfTerms} unionOfTerms\r\n\t * @param {Array.<Number>} range [start, end]\r\n\t * @param {number} points number of partition points\r\n\t * @returns {number}\r\n\t */\n\tfunction getMassCenter(unionOfTerms, range, points) {\n\t    var delta = (range[1] - range[0]) / (points || 100);\n\t    var S = 0;\n\t    var currentStep = range[0];\n\t\n\t    while (currentStep < range[1]) {\n\t        currentStep += delta;\n\t        S += delta * unionOfTerms.valueAt(currentStep);\n\t    }\n\t\n\t    currentStep = range[0];\n\t    var newS = 0;\n\t    var half_S = S / 2;\n\t    while (newS < half_S) {\n\t        currentStep += delta;\n\t        newS += delta * unionOfTerms.valueAt(currentStep);\n\t    }\n\t\n\t    // now it equals to 'mass center'. In prev point S < S/2, in next point  S > S/2\n\t    return currentStep;\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * Describes Term limited by belief degree.\r\n\t */\n\tvar CorrectedTerm = function () {\n\t    /**\r\n\t     *\r\n\t     * @param {Term} term\r\n\t     * @param {number} beliefDegree\r\n\t     */\n\t    function CorrectedTerm(term, beliefDegree) {\n\t        _classCallCheck(this, CorrectedTerm);\n\t\n\t        if (typeof term === 'undefined' || typeof beliefDegree === 'undefined') throw new Error('Corrected term: no params for constructor');\n\t        this.term = term;\n\t        this.beliefDegree = beliefDegree;\n\t    }\n\t\n\t    /**\r\n\t     *\r\n\t     * @param {number} x\r\n\t     * @returns {number}\r\n\t     */\n\t\n\t\n\t    _createClass(CorrectedTerm, [{\n\t        key: 'valueAt',\n\t        value: function valueAt(x) {\n\t            if (!this.term || this.beliefDegree === 0) {\n\t                return 0;\n\t            }\n\t\n\t            var termValue = this.term.valueAt(x);\n\t            var beliefDegree = this.beliefDegree;\n\t\n\t            return Math.min(beliefDegree, termValue);\n\t        }\n\t    }]);\n\t\n\t    return CorrectedTerm;\n\t}();\n\t\n\tmodule.exports = CorrectedTerm;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * Union of n Terms acts like Term which returns max value from all Terms in Union for specified point\r\n\t */\n\tvar UnionOfTerms = function () {\n\t    /**\r\n\t     *\r\n\t     * @param {Array.<Term>} arrayOfTerms\r\n\t     */\n\t    function UnionOfTerms(arrayOfTerms) {\n\t        _classCallCheck(this, UnionOfTerms);\n\t\n\t        this.arrayOfTerms = arrayOfTerms;\n\t    }\n\t\n\t    /**\r\n\t     *\r\n\t     * @param {number} x\r\n\t     * @returns {number} max value from all Terms\r\n\t     */\n\t\n\t\n\t    _createClass(UnionOfTerms, [{\n\t        key: 'valueAt',\n\t        value: function valueAt(x) {\n\t            if (!this.arrayOfTerms[0]) throw new Error('UnionOfTerms.valueAt: No terms in Union');\n\t\n\t            var max = this.arrayOfTerms[0].valueAt(x);\n\t            this.arrayOfTerms.forEach(function (term) {\n\t                if (term) {\n\t                    max = Math.max(max, term.valueAt(x));\n\t                }\n\t            });\n\t\n\t            return max;\n\t        }\n\t    }]);\n\t\n\t    return UnionOfTerms;\n\t}();\n\t\n\tmodule.exports = UnionOfTerms;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = {\n\t    indexOfObjByAttr: indexOfObjByAttr,\n\t    getMin: getMin,\n\t    getMax: getMax,\n\t    minOfTwoFunctions: minOfTwoFunctions,\n\t    maxOfTwoFunctions: maxOfTwoFunctions,\n\t    getMinOrMaxOfTwoFunction: getMinOrMaxOfTwoFunction,\n\t    getMaxFromFunctions: getMaxFromFunctions,\n\t    objClear: objClear\n\t};\n\t\n\t/**\r\n\t * Searches in array for an object which has specified pair attr:value\r\n\t * @param {Array.<Object>} array\r\n\t * @param {string} attr\r\n\t * @param value\r\n\t * @returns {number} index of obj or -1 if not found\r\n\t */\n\tfunction indexOfObjByAttr(array, attr, value) {\n\t    for (var i = 0; i < array.length; i += 1) {\n\t        if (array[i][attr] === value) {\n\t            return i;\n\t        }\n\t    }\n\t\n\t    return -1;\n\t}\n\t\n\t/**\r\n\t * Null is not compares with numbers.\r\n\t * @param {Array.<Number>} array\r\n\t * @returns {number | null}\r\n\t */\n\tfunction getMin(array) {\n\t    if (!array.length) return null;\n\t    var min = null;\n\t\n\t    for (var i = 0; i < array.length; i++) {\n\t        if (array[i] !== null && (min === null || array[i] < min)) min = array[i];\n\t    }\n\t\n\t    return min;\n\t}\n\t\n\t/**\r\n\t * Null is not compares with numbers.\r\n\t * @param array\r\n\t * @returns {number | null}\r\n\t */\n\tfunction getMax(array) {\n\t    if (!array.length) return null;\n\t    var max = null;\n\t\n\t    for (var i = 0; i < array.length; i++) {\n\t        if (array[i] !== null && (max === null || array[i] > max)) max = array[i];\n\t    }\n\t\n\t    return max;\n\t}\n\t\n\t/**\r\n\t * Get min value of two functions at specific point\r\n\t * @param {function|Number} f1\r\n\t * @param {function|Number} f2\r\n\t * @param {number} point\r\n\t * @returns {number}\r\n\t */\n\tfunction minOfTwoFunctions(f1, f2, point) {\n\t    return getMinOrMaxOfTwoFunction(f1, f2, point, true);\n\t}\n\t\n\t/**\r\n\t * Get min value of two functions at specific point\r\n\t * @param {function|Number} f1\r\n\t * @param {function|Number} f2\r\n\t * @param {number} point\r\n\t * @returns {number}\r\n\t */\n\tfunction maxOfTwoFunctions(f1, f2, point) {\n\t    return getMinOrMaxOfTwoFunction(f1, f2, point, false);\n\t}\n\t\n\t/**\r\n\t * Get min or max value of two functions at specific point\r\n\t * @param {function|Number} f1\r\n\t * @param {function|Number} f2\r\n\t * @param {number} point\r\n\t * @param {boolean} isMin\r\n\t * @returns {number|null}\r\n\t */\n\tfunction getMinOrMaxOfTwoFunction(f1, f2, point, isMin) {\n\t    var value1 = null;\n\t    var value2 = null;\n\t\n\t    if (typeof f1 === \"function\") {\n\t        value1 = f1(point);\n\t    } else if (f1 !== null) value1 = f1;\n\t\n\t    if (typeof f2 === \"function\") {\n\t        value2 = f2(point);\n\t    } else if (f2 !== null) value2 = f2;\n\t\n\t    if (typeof f1 !== 'function' && typeof f2 !== 'function') {\n\t        return null;\n\t    }\n\t\n\t    if (value1 !== null && value2 !== null) {\n\t        if (isMin) {\n\t            return value1 < value2 ? value1 : value2;\n\t        } else {\n\t            return value1 > value2 ? value1 : value2;\n\t        }\n\t    } else if (value1 === null) return value2;\n\t\n\t    return value1;\n\t}\n\t\n\t/**\r\n\t * Get max value at specific point from all specified functions\r\n\t * @param {Array.<function>} arrayOfFunctions\r\n\t * @param {number} x\r\n\t * @returns {number}\r\n\t */\n\tfunction getMaxFromFunctions(arrayOfFunctions, x) {\n\t    var max = 0;\n\t    arrayOfFunctions.forEach(function (func) {\n\t        if (func) {\n\t            var value = func(x);\n\t            if (value > max) max = value;\n\t        }\n\t    });\n\t\n\t    return max;\n\t}\n\t\n\t/**\r\n\t * Removes all own object properties.\r\n\t * @param obj\r\n\t */\n\tfunction objClear(obj) {\n\t    if (!obj) return;\n\t    for (var member in obj) {\n\t        if (obj.hasOwnProperty(member)) {\n\t            delete obj[member];\n\t        }\n\t    }\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar indexOfObjByAttr = __webpack_require__(4).indexOfObjByAttr;\n\tvar Term = __webpack_require__(6);\n\t\n\t/**\r\n\t * Describes a Linguistic Variable - parameter for fuzzy inference system\r\n\t * It is a linguistic expression (one or more words) labeling an information\r\n\t */\n\t\n\tvar LinguisticVariable = function () {\n\t    /**\r\n\t     * @param {string} name\r\n\t     * @param {Array.<Number>} range\r\n\t     * @param {Array.<Term>} terms\r\n\t     */\n\t    function LinguisticVariable(name) {\n\t        var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 1];\n\t        var terms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t\n\t        _classCallCheck(this, LinguisticVariable);\n\t\n\t        if (!name) throw new Error('Linguistic Variable must be named');\n\t        this.name = name;\n\t        this.range = range;\n\t        this.terms = terms;\n\t    }\n\t\n\t    /**\r\n\t     * @param {Term} term\r\n\t     */\n\t\n\t\n\t    _createClass(LinguisticVariable, [{\n\t        key: 'addTerm',\n\t        value: function addTerm(term) {\n\t            if (!(term instanceof Term)) throw new Error('addTerm: ' + term + ' is not an instance of Term.');\n\t            this.terms.push(term);\n\t        }\n\t\n\t        /**\r\n\t         * @param {string} termName\r\n\t         * @returns {Term|null}\r\n\t         */\n\t\n\t    }, {\n\t        key: 'findTerm',\n\t        value: function findTerm(termName) {\n\t            var index = indexOfObjByAttr(this.terms, \"name\", termName);\n\t            if (index > -1) {\n\t                return this.terms[index];\n\t            }\n\t\n\t            return null;\n\t        }\n\t\n\t        /**\r\n\t         * @param {string} termName\r\n\t         * @returns {boolean} is removal was success\r\n\t         */\n\t\n\t    }, {\n\t        key: 'removeTerm',\n\t        value: function removeTerm(termName) {\n\t            var index = indexOfObjByAttr(this.terms, \"name\", termName);\n\t            if (index > -1) {\n\t                this.terms.splice(indexOfObjByAttr, 1);\n\t                return true;\n\t            }\n\t\n\t            return false;\n\t        }\n\t    }]);\n\t\n\t    return LinguisticVariable;\n\t}();\n\t\n\tmodule.exports = LinguisticVariable;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar mfTypes = __webpack_require__(7);\n\t\n\t/**\r\n\t * Describes Term for linguistic variables.\r\n\t * Term is a fuzzy definition of some variable. Like 'tall', 'low' - about height\r\n\t */\n\t\n\tvar Term = function () {\n\t    /**\r\n\t     *\r\n\t     * @param {string} name name of the Term ('tall', 'low', 'yong', 'old', 'fast', 'slow', etc...)\r\n\t     * @param {string} mfType type of membership functions. See mfTypes.\r\n\t     * @param {Array.<number>} mfParams parameters of the membership function. Here is some defaults.\r\n\t     */\n\t    function Term(name) {\n\t        var mfType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'triangle';\n\t        var mfParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getDefaultParams(mfType);\n\t\n\t        _classCallCheck(this, Term);\n\t\n\t        this.name = name;\n\t\n\t        if (!mfTypes[mfType]) mfType = 'triangle';\n\t        this.mfType = mfType;\n\t        this.mf = mfTypes[mfType];\n\t        this.mfParams = mfParams;\n\t    }\n\t\n\t    /**\r\n\t     * Returns membership function value at x\r\n\t     * @param {number} x\r\n\t     * @returns {number}\r\n\t     */\n\t\n\t\n\t    _createClass(Term, [{\n\t        key: 'valueAt',\n\t        value: function valueAt(x) {\n\t            var args = this.mfParams.slice();\n\t            args.splice(0, 0, x); // insert to args value of x as first param\n\t            return this.mf.apply(this, args);\n\t        }\n\t    }]);\n\t\n\t    return Term;\n\t}();\n\t\n\tmodule.exports = Term;\n\t\n\t/**\r\n\t * Some predefined args.\r\n\t * @param {string} mf membership function type from mfTypes\r\n\t * @param {Array.<number>} range domain of linguistic variable\r\n\t *\r\n\t */\n\tfunction getDefaultParams(mf) {\n\t    var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 1];\n\t\n\t\n\t    var args = [];\n\t    range = range[1] - range[0];\n\t\n\t    switch (mf) {\n\t        case 'triangle':\n\t            args = [parseFloat((0.1 * range).toFixed(4)), parseFloat((0.5 * range).toFixed(4)), parseFloat((0.9 * range).toFixed(4))];\n\t            break;\n\t        case 'trapeze':\n\t            args = [parseFloat((0.1 * range).toFixed(4)), parseFloat((0.4 * range).toFixed(4)), parseFloat((0.6 * range).toFixed(4)), parseFloat((0.9 * range).toFixed(4))];\n\t            break;\n\t        case 'gauss':\n\t            args = [parseFloat((0.17 * range).toFixed(4)), parseFloat((0.5 * range).toFixed(4))];\n\t            break;\n\t        case 'sigma':\n\t            args = [parseFloat((18 / range).toFixed(4)), parseFloat((0.5 * range).toFixed(4))];\n\t            break;\n\t        case 'singleton':\n\t            args = [parseFloat((0.5 * range).toFixed(4))];\n\t            break;\n\t        default:\n\t            throw new Error('getDefaultParams: unrecognized mfType ' + mf);\n\t    }\n\t\n\t    return args;\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// типы функций принадлежности\n\tmodule.exports = {\n\t    triangle: mf_triangle,\n\t    trapeze: mf_trapezoidal,\n\t    gauss: mf_gaussian,\n\t    sigma: mf_sigmoid,\n\t    singleton: mf_singleton\n\t};\n\t\n\t/**\r\n\t * Triangle membership function.\r\n\t * @param {number} input\r\n\t * @param {number} left border of domain function, f(left) = 0 (pessimistic estimate)\r\n\t * @param {number} max coordinate where f(max) = 1 (optimistic estimate)\r\n\t * @param {number} right border of domain function, f(right) = 0 (pessimistic estimate)\r\n\t * @returns {number}\r\n\t */\n\tfunction mf_triangle(input, left, max, right) {\n\t    if (input < left || input > right) return 0;\n\t    if (left <= input && input <= max) return (input - left) / (max - left);\n\t\n\t    return (right - input) / (right - max);\n\t}\n\t\n\t/**\r\n\t * Trapezoidal membership function.\r\n\t * @param {number} input\r\n\t * @param {number} left f(left) = 0\r\n\t * @param {number} maxLeft f(maxLeft) = 1\r\n\t * @param {number} maxRight f(maxRight) = 1\r\n\t * @param {number} right f(right) = 0\r\n\t * @returns {number}\r\n\t */\n\tfunction mf_trapezoidal(input, left, maxLeft, maxRight, right) {\n\t    if (input < left || input > right) return 0;\n\t    if (left <= input && input <= maxLeft) return (input - left) / (maxLeft - left);\n\t    if (maxLeft <= input && input <= maxRight) return 1;\n\t    return (right - input) / (right - maxRight);\n\t}\n\t\n\t/**\r\n\t * Gaussian membership function.\r\n\t * @param {number} input\r\n\t * @param {number} concentration coefficient\r\n\t * @param {number} max f(max) = 1\r\n\t * @returns {number}\r\n\t */\n\tfunction mf_gaussian(input, concentration, max) {\n\t    return input === max ? 1 : Math.exp(-1 * ((input - max) * (input - max)) / (2 * concentration * concentration));\n\t}\n\t\n\t/**\r\n\t * Sigmoid membership function.\r\n\t * @param {number} input\r\n\t * @param {number} steepness coefficient\r\n\t * @param {number} transitionCoordinate f(transitionCoordinate) = 0.5\r\n\t * @returns {number}\r\n\t */\n\tfunction mf_sigmoid(input, steepness, transitionCoordinate) {\n\t    return input === transitionCoordinate ? 0.5 : 1 / (1 + Math.exp(-1 * steepness * (input - transitionCoordinate)));\n\t}\n\t\n\t/**\r\n\t * Singleton membership function.\r\n\t * @param {number} input\r\n\t * @param {number} number concrete value. f(number) = 1 otherwise 0\r\n\t * @returns {number} 0 or 1\r\n\t */\n\tfunction mf_singleton(input, number) {\n\t    return input === number ? 1 : 0;\n\t}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * Describe a rule for fuzzy inference system.\r\n\t * Rule is:\r\n\t * 1) Matching for every linguistic variable with one of it terms.\r\n\t * 2) Connection between input terms of linguistic variables: \"or\" / \"and\"\r\n\t *      example: if *food* is good AND *service* is normal than *tips* should be good\r\n\t * 3) Weight coefficient of Rule. Or how much rule will effort on system's conclusions.\r\n\t */\n\tvar Rule =\n\t/**\r\n\t * @param {Array.<string>} conditions массив вида [терм-значение-первой-LV, терм-значение-второй-LV...]\r\n\t * @param {Array.<string>} conclusions\r\n\t * @param {string} connection\r\n\t * @param {number} weight\r\n\t */\n\tfunction Rule(conditions, conclusions) {\n\t    var connection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'and';\n\t    var weight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\t\n\t    _classCallCheck(this, Rule);\n\t\n\t    if (!conditions || !conclusions || !conditions.length || !conclusions.length) throw new Error('Rule: check input params');\n\t\n\t    this.conditions = conditions.map(function (c) {\n\t        if (c === \"null\") return null;else return c;\n\t    });\n\t\n\t    this.conclusions = conclusions.map(function (c) {\n\t        if (c === \"null\") return null;else return c;\n\t    });\n\t\n\t    if (typeof connection === \"string\") {\n\t        if (connection.toLowerCase() === \"or\") {\n\t            this.connection = \"or\";\n\t        } else {\n\t            this.connection = \"and\";\n\t        }\n\t    } else throw new Error('Rule: unrecognized connection ' + connection);\n\t\n\t    this.weight = weight;\n\t};\n\t\n\tmodule.exports = Rule;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// fuzzyis-v1.0.0.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4e2f8f85568c34547f34","module.exports = {\r\n    FIS: require('./FIS'),\r\n    LinguisticVariable: require('./LinguisticVariable'),\r\n    Term: require('./Term'),\r\n    Rule: require('./Rule')\r\n};\n\n\n// WEBPACK FOOTER //\n// ./lib/index.js","const CorrectedTerm = require('./CorrectedTerm');\r\nconst UnionOfTerms = require('./UnionOfTerms');\r\nconst helpers = require('./helpers');\r\n\r\n/**\r\n * Describes Fuzzy Inference System\r\n * Put LinguisticVariables into inputs and outputs, describe system rules\r\n * And get precise outputs from precise input values.\r\n */\r\nclass FIS {\r\n    /**\r\n     * Creates empty system without any rules and i/o linguistic variables\r\n     * @param {string} name\r\n     * @param {Array.<LinguisticVariable>} inputs\r\n     * @param {Array.<LinguisticVariable>} outputs\r\n     * @param {Array.<Rule>} rules\r\n     */\r\n    constructor (name = \"Unnamed system\", inputs = [], outputs = [], rules = []) {\r\n        this.name = name;\r\n\r\n        // linguistic variables\r\n        this.inputs = inputs;\r\n        this.outputs = outputs;\r\n\r\n        this.rules = rules;\r\n    }\r\n\r\n    /**\r\n     * @param {LinguisticVariable} LV\r\n     */\r\n    addInput (LV) {\r\n        this.inputs.push(LV);\r\n    }\r\n\r\n    /**\r\n     * @param {LinguisticVariable} LV\r\n     */\r\n    addOutput (LV) {\r\n        this.outputs.push(LV);\r\n    }\r\n\r\n    /**\r\n     * @param {Rule} rule\r\n     */\r\n    addRule (rule) {\r\n       this.rules.push(rule);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Array.<number>} inputValues Precise values for input linguistic variables\r\n     * @returns {Array.<number>} Precise values for input linguistic variables\r\n     */\r\n    getPreciseOutput (inputValues) {\r\n        let leftParts = getLeftParts(inputValues, this);\r\n\r\n        // for each Rule we should find belief degree\r\n\r\n        let rightParts = [];\r\n        let i;\r\n        for (i = 0; i < this.rules.length; i++) {\r\n            let rule = this.rules[i];\r\n            rule.beliefDegree = (rule.connection) === \"and\" ? helpers.getMin(leftParts[i]) : getMax(leftParts[i]);\r\n            rule.beliefDegree *= rule.weight;\r\n    \r\n            // filling the right parts\r\n            rightParts.push([]);\r\n            for (let j = 0; j < rule.conclusions.length; j++) {\r\n                let term = this.outputs[j].findTerm(rule.conclusions[j]);\r\n                rightParts[i].push(new CorrectedTerm(term, rule.beliefDegree));\r\n            }\r\n    \r\n        }\r\n    \r\n        let unionOfCorrectedTerms = [];\r\n    \r\n        //outputs\r\n        for (i = 0; i < this.outputs.length; i++) {\r\n            // rules\r\n            let union = [];\r\n            for (let k = 0; k < rightParts.length; k++) {\r\n                union.push(rightParts[k][i]);\r\n            }\r\n            unionOfCorrectedTerms.push(new UnionOfTerms(union));\r\n        }\r\n    \r\n        let results = [];\r\n    \r\n        for (i = 0; i < this.outputs.length; i++) {\r\n            let result = getMassCenter(unionOfCorrectedTerms[i], this.outputs[i].range, 100);\r\n            results.push(result);\r\n        }\r\n    \r\n        return results;\r\n    }\r\n}\r\n\r\nmodule.exports = FIS;\r\n\r\n/**\r\n *\r\n * @param {Array.<LinguisticVariable>} inputValues\r\n * @param system {FIS}\r\n * @returns {Array}\r\n */\r\nfunction getLeftParts(inputValues, system) {\r\n    let leftParts = [];\r\n    let inputsAmount = system.inputs.length;\r\n    for (let i = 0; i < system.rules.length; i++) {\r\n        // for each Rule get values at the right parts\r\n        leftParts.push([]);\r\n        for (let j = 0; j < inputsAmount; j++) {\r\n            if (system.rules[i].conditions[j]) {\r\n                let term = system.inputs[j].findTerm(system.rules[i].conditions[j]);\r\n                leftParts[i].push(term.valueAt(inputValues[j]));\r\n            } else {\r\n                leftParts[i].push(null);\r\n            }\r\n        }\r\n    }\r\n\r\n    return leftParts;\r\n}\r\n\r\n/**\r\n * Searches for point in which Square under f equals to half on specific interval.\r\n * @param {UnionOfTerms} unionOfTerms\r\n * @param {Array.<Number>} range [start, end]\r\n * @param {number} points number of partition points\r\n * @returns {number}\r\n */\r\nfunction getMassCenter(unionOfTerms, range, points) {\r\n    let delta = (range[1] - range[0]) / (points || 100);\r\n    let S = 0;\r\n    let currentStep = range[0];\r\n\r\n    while (currentStep < range[1]) {\r\n        currentStep += delta;\r\n        S += delta * unionOfTerms.valueAt(currentStep);\r\n    }\r\n\r\n    currentStep = range[0];\r\n    let newS = 0;\r\n    let half_S = S / 2;\r\n    while (newS < half_S) {\r\n        currentStep += delta;\r\n        newS += delta * unionOfTerms.valueAt(currentStep);\r\n    }\r\n\r\n    // now it equals to 'mass center'. In prev point S < S/2, in next point  S > S/2\r\n    return currentStep;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/FIS.js","/**\r\n * Describes Term limited by belief degree.\r\n */\r\nclass CorrectedTerm {\r\n    /**\r\n     *\r\n     * @param {Term} term\r\n     * @param {number} beliefDegree\r\n     */\r\n    constructor(term, beliefDegree){\r\n        if (typeof term === 'undefined' || typeof beliefDegree === 'undefined')\r\n            throw new Error('Corrected term: no params for constructor');\r\n        this.term = term;\r\n        this.beliefDegree = beliefDegree;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} x\r\n     * @returns {number}\r\n     */\r\n    valueAt (x) {\r\n        if (!this.term || this.beliefDegree === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let termValue = this.term.valueAt(x);\r\n        let beliefDegree = this.beliefDegree;\r\n\r\n        return Math.min(beliefDegree, termValue);\r\n    }\r\n}\r\n\r\nmodule.exports = CorrectedTerm;\n\n\n// WEBPACK FOOTER //\n// ./lib/CorrectedTerm.js","/**\r\n * Union of n Terms acts like Term which returns max value from all Terms in Union for specified point\r\n */\r\nclass UnionOfTerms {\r\n    /**\r\n     *\r\n     * @param {Array.<Term>} arrayOfTerms\r\n     */\r\n    constructor(arrayOfTerms) {\r\n        this.arrayOfTerms = arrayOfTerms;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} x\r\n     * @returns {number} max value from all Terms\r\n     */\r\n    valueAt (x) {\r\n        if (!this.arrayOfTerms[0]) throw new Error('UnionOfTerms.valueAt: No terms in Union');\r\n\r\n        let max = this.arrayOfTerms[0].valueAt(x);\r\n        this.arrayOfTerms.forEach((term) => {\r\n            if (term) {\r\n                max = Math.max(max, term.valueAt(x));\r\n            }\r\n        });\r\n\r\n        return max;\r\n    };\r\n}\r\n\r\nmodule.exports = UnionOfTerms;\n\n\n// WEBPACK FOOTER //\n// ./lib/UnionOfTerms.js","module.exports = {\r\n    indexOfObjByAttr,\r\n    getMin,\r\n    getMax,\r\n    minOfTwoFunctions,\r\n    maxOfTwoFunctions,\r\n    getMinOrMaxOfTwoFunction,\r\n    getMaxFromFunctions,\r\n    objClear\r\n};\r\n\r\n/**\r\n * Searches in array for an object which has specified pair attr:value\r\n * @param {Array.<Object>} array\r\n * @param {string} attr\r\n * @param value\r\n * @returns {number} index of obj or -1 if not found\r\n */\r\nfunction indexOfObjByAttr(array, attr, value) {\r\n    for(let i = 0; i < array.length; i += 1) {\r\n        if(array[i][attr] === value) {\r\n            return i;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\n/**\r\n * Null is not compares with numbers.\r\n * @param {Array.<Number>} array\r\n * @returns {number | null}\r\n */\r\nfunction getMin(array) {\r\n    if (!array.length) return null;\r\n    let min = null;\r\n\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (array[i] !== null && (min === null || array[i] < min)) min = array[i];\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\n/**\r\n * Null is not compares with numbers.\r\n * @param array\r\n * @returns {number | null}\r\n */\r\nfunction getMax(array) {\r\n    if (!array.length) return null;\r\n    var max = null;\r\n\r\n    for (var i = 0; i < array.length; i++) {\r\n        if (array[i] !== null && (max === null || array[i] > max)) max = array[i];\r\n    }\r\n\r\n    return max;\r\n}\r\n\r\n/**\r\n * Get min value of two functions at specific point\r\n * @param {function|Number} f1\r\n * @param {function|Number} f2\r\n * @param {number} point\r\n * @returns {number}\r\n */\r\nfunction minOfTwoFunctions(f1, f2, point) {\r\n    return getMinOrMaxOfTwoFunction(f1, f2, point, true);\r\n}\r\n\r\n/**\r\n * Get min value of two functions at specific point\r\n * @param {function|Number} f1\r\n * @param {function|Number} f2\r\n * @param {number} point\r\n * @returns {number}\r\n */\r\nfunction maxOfTwoFunctions(f1, f2, point) {\r\n    return getMinOrMaxOfTwoFunction(f1, f2, point, false);\r\n}\r\n\r\n/**\r\n * Get min or max value of two functions at specific point\r\n * @param {function|Number} f1\r\n * @param {function|Number} f2\r\n * @param {number} point\r\n * @param {boolean} isMin\r\n * @returns {number|null}\r\n */\r\nfunction getMinOrMaxOfTwoFunction(f1, f2, point, isMin) {\r\n    let value1 = null;\r\n    let value2 = null;\r\n\r\n    if (typeof(f1) === \"function\") {\r\n        value1 = f1(point);\r\n    } else if (f1 !== null) value1 = f1;\r\n\r\n    if (typeof(f2) === \"function\") {\r\n        value2 = f2(point);\r\n    } else if (f2 !== null) value2 = f2;\r\n\r\n    if (typeof(f1) !== 'function' && typeof(f2) !== 'function') {\r\n        return null;\r\n    }\r\n\r\n    if (value1 !== null && value2 !== null) {\r\n        if (isMin) {\r\n            return (value1 < value2) ? value1 : value2;\r\n        } else {\r\n            return (value1 > value2) ? value1 : value2;\r\n        }\r\n    } else if (value1 === null) return value2;\r\n\r\n    return value1;\r\n}\r\n\r\n/**\r\n * Get max value at specific point from all specified functions\r\n * @param {Array.<function>} arrayOfFunctions\r\n * @param {number} x\r\n * @returns {number}\r\n */\r\nfunction getMaxFromFunctions(arrayOfFunctions, x) {\r\n    var max = 0;\r\n    arrayOfFunctions.forEach(function(func) {\r\n        if (func) {\r\n            var value = func(x);\r\n            if (value > max) max = value;\r\n        }\r\n    });\r\n\r\n    return max;\r\n}\r\n\r\n/**\r\n * Removes all own object properties.\r\n * @param obj\r\n */\r\nfunction objClear(obj) {\r\n    if (!obj) return;\r\n    for (let member in obj) {\r\n        if (obj.hasOwnProperty(member)) {\r\n            delete obj[member];\r\n        }\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/helpers.js","const indexOfObjByAttr = require('./helpers').indexOfObjByAttr;\r\nconst Term = require('./Term');\r\n\r\n/**\r\n * Describes a Linguistic Variable - parameter for fuzzy inference system\r\n * It is a linguistic expression (one or more words) labeling an information\r\n */\r\nclass LinguisticVariable {\r\n    /**\r\n     * @param {string} name\r\n     * @param {Array.<Number>} range\r\n     * @param {Array.<Term>} terms\r\n     */\r\n    constructor (name, range = [0, 1], terms = []) {\r\n        if (!name) throw new Error('Linguistic Variable must be named');\r\n        this.name = name;\r\n        this.range = range;\r\n        this.terms = terms;\r\n    }\r\n\r\n    /**\r\n     * @param {Term} term\r\n     */\r\n    addTerm (term) {\r\n        if (!(term instanceof Term)) throw new Error(`addTerm: ${term} is not an instance of Term.`);\r\n        this.terms.push(term);\r\n    }\r\n\r\n    /**\r\n     * @param {string} termName\r\n     * @returns {Term|null}\r\n     */\r\n    findTerm (termName) {\r\n        let index = indexOfObjByAttr(this.terms, \"name\", termName);\r\n        if (index > -1) {\r\n            return this.terms[index];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @param {string} termName\r\n     * @returns {boolean} is removal was success\r\n     */\r\n    removeTerm (termName) {\r\n        let index = indexOfObjByAttr(this.terms, \"name\", termName);\r\n        if (index > -1) {\r\n            this.terms.splice(indexOfObjByAttr, 1);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\nmodule.exports = LinguisticVariable;\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./lib/LinguisticVariable.js","const mfTypes = require('./mfTypes');\r\n\r\n/**\r\n * Describes Term for linguistic variables.\r\n * Term is a fuzzy definition of some variable. Like 'tall', 'low' - about height\r\n */\r\nclass Term {\r\n    /**\r\n     *\r\n     * @param {string} name name of the Term ('tall', 'low', 'yong', 'old', 'fast', 'slow', etc...)\r\n     * @param {string} mfType type of membership functions. See mfTypes.\r\n     * @param {Array.<number>} mfParams parameters of the membership function. Here is some defaults.\r\n     */\r\n    constructor (name, mfType = 'triangle', mfParams = getDefaultParams(mfType)) {\r\n        this.name = name;\r\n\r\n        if (!mfTypes[mfType]) mfType = 'triangle';\r\n        this.mfType = mfType;\r\n        this.mf = mfTypes[mfType];\r\n        this.mfParams = mfParams;\r\n    }\r\n\r\n    /**\r\n     * Returns membership function value at x\r\n     * @param {number} x\r\n     * @returns {number}\r\n     */\r\n    valueAt (x) {\r\n        let args = this.mfParams.slice();\r\n        args.splice(0, 0, x); // insert to args value of x as first param\r\n        return this.mf.apply(this, args);\r\n    };\r\n}\r\n\r\nmodule.exports = Term;\r\n\r\n/**\r\n * Some predefined args.\r\n * @param {string} mf membership function type from mfTypes\r\n * @param {Array.<number>} range domain of linguistic variable\r\n *\r\n */\r\nfunction getDefaultParams(mf, range = [0, 1]) {\r\n\r\n    let args = [];\r\n    range = range[1] - range[0];\r\n\r\n    switch (mf) {\r\n        case 'triangle' :\r\n            args = [parseFloat((0.1 * range).toFixed(4)), parseFloat((0.5 * range).toFixed(4)), parseFloat((0.9 * range).toFixed(4))];\r\n            break;\r\n        case 'trapeze':\r\n            args = [parseFloat((0.1 * range).toFixed(4)), parseFloat((0.4 * range).toFixed(4)), parseFloat((0.6 * range).toFixed(4)), parseFloat((0.9 * range).toFixed(4))];\r\n            break;\r\n        case 'gauss':\r\n            args = [parseFloat((0.17 * range).toFixed(4)), parseFloat((0.5 * range).toFixed(4))];\r\n            break;\r\n        case 'sigma':\r\n            args = [parseFloat((18 / range).toFixed(4)), parseFloat((0.5 * range).toFixed(4))];\r\n            break;\r\n        case 'singleton':\r\n            args = [parseFloat((0.5 * range).toFixed(4))];\r\n            break;\r\n        default: throw new Error(`getDefaultParams: unrecognized mfType ${mf}`);\r\n    }\r\n\r\n    return args;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/Term.js","// типы функций принадлежности\r\nmodule.exports = {\r\n    triangle: mf_triangle,\r\n    trapeze: mf_trapezoidal,\r\n    gauss: mf_gaussian,\r\n    sigma: mf_sigmoid,\r\n    singleton: mf_singleton\r\n};\r\n\r\n/**\r\n * Triangle membership function.\r\n * @param {number} input\r\n * @param {number} left border of domain function, f(left) = 0 (pessimistic estimate)\r\n * @param {number} max coordinate where f(max) = 1 (optimistic estimate)\r\n * @param {number} right border of domain function, f(right) = 0 (pessimistic estimate)\r\n * @returns {number}\r\n */\r\nfunction mf_triangle(input, left, max, right) {\r\n    if (input < left || input > right) return 0;\r\n    if (left <= input && input <= max) return (input - left) / (max - left);\r\n\r\n    return (right - input) / (right - max);\r\n}\r\n\r\n/**\r\n * Trapezoidal membership function.\r\n * @param {number} input\r\n * @param {number} left f(left) = 0\r\n * @param {number} maxLeft f(maxLeft) = 1\r\n * @param {number} maxRight f(maxRight) = 1\r\n * @param {number} right f(right) = 0\r\n * @returns {number}\r\n */\r\nfunction mf_trapezoidal(input, left, maxLeft, maxRight, right) {\r\n    if (input < left || input > right) return 0;\r\n    if (left <= input && input <= maxLeft) return (input - left) / (maxLeft - left);\r\n    if (maxLeft <= input && input <= maxRight) return 1;\r\n    return (right - input) / (right - maxRight);\r\n}\r\n\r\n/**\r\n * Gaussian membership function.\r\n * @param {number} input\r\n * @param {number} concentration coefficient\r\n * @param {number} max f(max) = 1\r\n * @returns {number}\r\n */\r\nfunction mf_gaussian(input, concentration, max) {\r\n    return (input === max) ? 1 :\r\n        Math.exp((-1) * ((input - max) * (input - max)) / (2 * concentration * concentration));\r\n}\r\n\r\n\r\n/**\r\n * Sigmoid membership function.\r\n * @param {number} input\r\n * @param {number} steepness coefficient\r\n * @param {number} transitionCoordinate f(transitionCoordinate) = 0.5\r\n * @returns {number}\r\n */\r\nfunction mf_sigmoid(input, steepness, transitionCoordinate) {\r\n    return (input === transitionCoordinate) ? 0.5 :\r\n        1 / (1 + Math.exp((-1) * steepness * (input - transitionCoordinate)));\r\n}\r\n\r\n/**\r\n * Singleton membership function.\r\n * @param {number} input\r\n * @param {number} number concrete value. f(number) = 1 otherwise 0\r\n * @returns {number} 0 or 1\r\n */\r\nfunction mf_singleton(input, number) {\r\n    return (input === number) ? 1 : 0;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/mfTypes.js","/**\r\n * Describe a rule for fuzzy inference system.\r\n * Rule is:\r\n * 1) Matching for every linguistic variable with one of it terms.\r\n * 2) Connection between input terms of linguistic variables: \"or\" / \"and\"\r\n *      example: if *food* is good AND *service* is normal than *tips* should be good\r\n * 3) Weight coefficient of Rule. Or how much rule will effort on system's conclusions.\r\n */\r\nclass Rule {\r\n    /**\r\n     * @param {Array.<string>} conditions массив вида [терм-значение-первой-LV, терм-значение-второй-LV...]\r\n     * @param {Array.<string>} conclusions\r\n     * @param {string} connection\r\n     * @param {number} weight\r\n     */\r\n    constructor (conditions, conclusions, connection = 'and', weight = 1) {\r\n        if (!conditions || !conclusions || !conditions.length || !conclusions.length)\r\n            throw new Error('Rule: check input params');\r\n\r\n        this.conditions = conditions.map(function(c) {\r\n            if (c === \"null\") return null;\r\n            else return c;\r\n        });\r\n\r\n        this.conclusions = conclusions.map(function(c) {\r\n            if (c === \"null\") return null;\r\n            else return c;\r\n        });\r\n\r\n        if (typeof(connection) === \"string\") {\r\n            if (connection.toLowerCase() === \"or\") {\r\n                this.connection = \"or\";\r\n            } else {\r\n                this.connection = \"and\";\r\n            }\r\n        } else throw new Error(`Rule: unrecognized connection ${connection}`);\r\n\r\n        this.weight = weight;\r\n    }\r\n}\r\n\r\nmodule.exports = Rule;\n\n\n// WEBPACK FOOTER //\n// ./lib/Rule.js"],"sourceRoot":""}